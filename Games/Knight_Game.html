<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Retro Knight Preview</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; user-select: none; }
        #ui-layer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #00ff00;
            font-size: 24px;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            z-index: 2;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 6px;
            background-color: white;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1;
        }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="ui-layer">CLICK TO START<br>WASD = MOVE<br>RIGHT CLICK = SWING</div>
    
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.126.0/build/three.module.js';
        import { PointerLockControls } from 'https://unpkg.com/three@0.126.0/examples/jsm/controls/PointerLockControls.js';

        let camera, scene, renderer, controls;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        
        // Sword Vars
        let sword;
        let isSwinging = false;
        let swingTime = 0;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x220033); // Retro purple/dark bg
            scene.fog = new THREE.Fog(0x220033, 0, 60);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Lighting
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
            hemiLight.position.set(0, 20, 0);
            scene.add(hemiLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff);
            dirLight.position.set(0, 20, 10);
            scene.add(dirLight);

            // Controls
            controls = new PointerLockControls(camera, document.body);

            const ui = document.getElementById('ui-layer');
            document.addEventListener('click', () => controls.lock());
            
            controls.addEventListener('lock', () => ui.style.display = 'none');
            controls.addEventListener('unlock', () => ui.style.display = 'block');
            
            scene.add(controls.getObject());

            // Input
            const onKeyDown = (event) => {
                switch (event.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyD': moveRight = true; break;
                }
            };
            const onKeyUp = (event) => {
                switch (event.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyD': moveRight = false; break;
                }
            };
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // Right Click Swing
            document.addEventListener('mousedown', (event) => {
                if(event.button === 2 && controls.isLocked && !isSwinging) {
                    isSwinging = true;
                    swingTime = 0;
                }
            });
            document.addEventListener('contextmenu', event => event.preventDefault());

            // World Generation
            // Floor
            const floorGeo = new THREE.PlaneGeometry(200, 200);
            floorGeo.rotateX(-Math.PI / 2);
            const floorMat = new THREE.MeshBasicMaterial({ color: 0x1a1a1a });
            // Grid Helper for retro feel
            const grid = new THREE.GridHelper(200, 50, 0x00ff00, 0x004400);
            scene.add(grid);
            scene.add(new THREE.Mesh(floorGeo, floorMat));

            // Pillars
            const boxGeo = new THREE.BoxGeometry(4, 10, 4);
            const boxMat = new THREE.MeshNormalMaterial({ wireframe: false }); 
            for(let i=0; i<20; i++) {
                const mesh = new THREE.Mesh(boxGeo, boxMat);
                mesh.position.x = (Math.random() - 0.5) * 100;
                mesh.position.y = 5;
                mesh.position.z = (Math.random() - 0.5) * 100;
                scene.add(mesh);
            }

            // Sword Construction
            createSword();

            renderer = new THREE.WebGLRenderer({ antialias: false }); // False for retro jagged edges
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            window.addEventListener('resize', onWindowResize);
        }

        function createSword() {
            sword = new THREE.Group();
            
            // Blade
            const bladeGeo = new THREE.BoxGeometry(0.5, 6, 0.1);
            const bladeMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
            const blade = new THREE.Mesh(bladeGeo, bladeMat);
            blade.position.y = 3;
            
            // Guard
            const guardGeo = new THREE.BoxGeometry(2, 0.3, 0.3);
            const guardMat = new THREE.MeshStandardMaterial({ color: 0x886600 });
            const guard = new THREE.Mesh(guardGeo, guardMat);
            
            // Handle
            const handleGeo = new THREE.CylinderGeometry(0.2, 0.2, 1.5);
            const handleMat = new THREE.MeshStandardMaterial({ color: 0x552200 });
            const handle = new THREE.Mesh(handleGeo, handleMat);
            handle.position.y = -1;

            sword.add(blade, guard, handle);
            
            // Attach to camera
            sword.position.set(2, -1.5, -3);
            sword.rotation.set(0.2, 0, 0);
            camera.add(sword);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            if (controls.isLocked) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 200.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 200.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);

                // Sword Animation
                if(isSwinging) {
                    swingTime += delta * 10;
                    sword.rotation.x = 0.2 + Math.sin(swingTime) * 1.5; // Chop down
                    sword.rotation.z = Math.sin(swingTime) * 0.5; // Slight tilt
                    
                    if(swingTime > Math.PI) {
                        isSwinging = false;
                        sword.rotation.set(0.2, 0, 0);
                    }
                } else {
                    // Bobbing
                    sword.position.y = -1.5 + Math.sin(time * 0.005) * 0.05;
                }
            }

            prevTime = time;
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>